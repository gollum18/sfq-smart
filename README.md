# SMART
Formerly known as SFQ-Smart. SMART is an attempt to make queuing smarter. SMART attempts to employ various forms of machine learning to determine bad queue from good queue.

## Description
At a high level, SMART associates queue characteristics with queue classification. SMART attempts to differentiate persistent congestion from temporary delay. Peristent delay arises from the persistently full buffer problem or more eponomously, bufferbloat. This research will make use of Reinforcement Learning, Markov Decision Processes, and simple Neural Networks such as Logistic Regression. These algorithms comprise a series of SMART variants that will be rigorously benchmarked against the Controlled Delay active queue management algorithm.

Certain machine learning algorithms make use of forward state prediction where the agent attempts to simulate the state of the environment by applying all actions available actions to the environment then evaluating the resulting states through an evaluation function. The maximum action is thus taken as the agents action and algorithm values are updated appropriately. This is impractical in an environment as dynamic as packet queue management. Instead, where appropriate, this algorithm creates a policy whereby the agent picks the probabilistic best action based on past events. The agent will then perform a step similar to backpropagation where the agent updates its policy based on evaluated real state.

Certain algorithms, such as Reinforcement Learning require the state space be encapsulated in a succint description. I have participated in projects incorporating reinforcement learning where we made the mistake of not doing so, and the state space grew too large for the agent to realistically maintain (see ['AI: Poker Project'](https://github.com/gollum18/Poker-Project) for an example. Therefore, where necessary, the agent will use a classification function to encapsulate the state of the router into a finite set of possible states. To ensure consistency, the classification function will make observations on most recent queue length and packet delay. These variables and their relevance to queue classification will be expounded on in a later section.

SMART makes no observations on the state of other routers in the network (as in fact, it cannot, unless Software Defined Networking (SDN) comes into play). Speaking on SDN, it is entirely possible that these algorithms would be better suited to being deployed in an SDN setting. In such a scenario, a remote server/host/client would be responsible for the control plane funcitonality of the router. The router is solely responsible for data plane functions such as forwarding through a table maintained via the controller. Since we are discussing the Internet, anything can happen. That is, I do not have enough trust in SDN to ensure it can perform well in a time-sensitive environment without overhead. Contrarily, SMART implements a handful of CPU-intensive computations. Fortunately, modern mid-tier routers (and certain commercial routers) are more than powerful enough to handle these algorithms.

One last note: SMART does not make any attempt to be a deep learning platform. In fact, SMART is designed for platforms that do not have the resources necessary for effective deep learning (routers do not come with GPUs, eh?) As stated above, perhaps this would be possible if SMART were deployed on an SDN platform, but that is not the goal of this project.

## Theory
SMART implements three machine learning models in packet scheduling: Reinforcement Learning, Markov Decision Processes, and Neural Networks. While most readers interested in SMART should be at least somewhat familiar with machine learning and the aforementioned ML categories, however, I will provide an overview here.

A few things to note before we delve into these three categories in depth:

+ Machine learning is not a cure all. It is very good at solving specific problems given enough data, however, regardless of the size or quality of the training set, no ML algorithm can bever be 100% accurate.
+ Normally, machine learning algorithms are trained *before* they are deployed. SMART cannot utilize this approach as it is impossible to obtain a training set of suitable size for the algorithm, therefore SMART will be trained on deployment. The algorithm will contain a means to exit training state autonomously.
+ The feature vector for training purposes will be rather small. Well established research has already been consulted to determine that only a handful of queue features are neccessary to accurately gauge queue state.
+ All three of the algorithms employed by SMART attempt to solve a specific optimization problem under certain conditions. At each iteration, the algorithms attempt to make the best decision to move them from their current state to the best potential state. Some algorithms simulate the environment before the agent actually enacts their will on the real environment. This is impossible in SMART, and as such, all SMART algorithms will probabilistically make the best decision and update said state transition probabilities after each iteration of the algorithm.
